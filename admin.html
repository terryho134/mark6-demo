<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mark6 管理頁</title>
  <style>
    body { font-family: system-ui, -apple-system, "PingFang HK", "Noto Sans TC", Arial, sans-serif; margin: 24px; line-height: 1.6; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 12px 0; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    input, button { padding: 8px 10px; }
    .muted { color:#666; font-size: 14px; }
    .error { color:#b00020; }
    .ok { color:#0a7a0a; }
    code { background:#f5f5f5; padding:2px 6px; border-radius:6px; }
    input[readonly] { background:#fafafa; }
    button { cursor: pointer; }
  </style>
</head>
<body>
  <h1>Mark6 管理頁（寫入 D1）</h1>
  <p class="muted">提示：密碼你而家設為 <code>123456</code>（非常易被猜中，建議之後改長啲）。</p>

  <div class="card">
    <div class="row">
      <label>管理密碼</label>
      <input id="key" type="password" placeholder="123456" />
      <button id="saveKey" type="button">記住密碼</button>
    </div>

    <hr style="margin:14px 0;border:none;border-top:1px solid #eee;">

    <h3 style="margin:0 0 8px;">今期攪珠結果</h3>

    <div class="row">
      <label>期數</label>
      <input id="drawNo" placeholder="例如：25/018" />
      <span class="muted" id="prefillHint"></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label>攪珠日期</label>
      <input id="drawDate" type="date" />
    </div>

    <div class="row" style="margin-top:10px;">
      <label>6 個號碼</label>
      <input id="nums" placeholder="例如：1 7 12 23 36 44" style="min-width: 320px;" />
      <label>特別號</label>
      <input id="special" type="number" min="1" max="49" style="width:90px;" />
    </div>

    <hr style="margin:14px 0;border:none;border-top:1px solid #eee;">

    <h3 style="margin:0 0 8px;">下期資料（可獨立更新）</h3>

    <div class="row">
      <label>下期攪珠日期</label>
      <input id="nextDrawDate" type="date" />
    </div>

    <div class="row" style="margin-top:10px;">
      <label>下期期數（自動）</label>
      <input id="nextDrawNo" readonly placeholder="會自動計算" />
      <span class="muted">同一年：+1；新一年：<code>001/新年份</code></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label>估計頭獎基金（百萬位）</label>
      <input id="nextJackpotM" type="number" min="0" step="1" style="width:120px;" placeholder="例如 22" />
      <span class="muted" id="jackpotHint"></span>
    </div>

    <div class="row" style="margin-top:14px;">
      <button id="submit" type="button">提交攪珠結果</button>
      <button id="submitNextOnly" type="button">只更新下期資料</button>
    </div>

    <div id="msg" class="muted" style="margin-top:12px;"></div>
  </div>

  <p><a href="/">返回首頁</a></p>

  <script>
    // ==========================================================
    // Admin page script
    // - Upsert draw result: /api/admin/upsert
    // - Update next meta independently: /api/admin/next
    //
    // IMPORTANT: 為避免 Unauthorized（後端可能驗證 X-Admin-Key 或 Authorization）
    // 這裡對 /api/admin/* 一律同時帶：
    //   - X-Admin-Key: <key>
    //   - Authorization: Bearer <key>
    // ==========================================================

    // -------------------------
    // DOM refs
    // -------------------------
    const keyEl = document.getElementById("key");
    const msgEl = document.getElementById("msg");

    const drawNoEl = document.getElementById("drawNo");
    const drawDateEl = document.getElementById("drawDate");
    const numsEl = document.getElementById("nums");
    const specialEl = document.getElementById("special");

    const nextDrawDateEl = document.getElementById("nextDrawDate");
    const nextDrawNoEl = document.getElementById("nextDrawNo");
    const nextJackpotMEl = document.getElementById("nextJackpotM");

    const prefillHintEl = document.getElementById("prefillHint");
    const jackpotHintEl = document.getElementById("jackpotHint");

    const saveKeyBtn = document.getElementById("saveKey");
    const submitBtn = document.getElementById("submit");
    const submitNextOnlyBtn = document.getElementById("submitNextOnly");

    // -------------------------
    // Key storage
    // -------------------------
    const SAVED_KEY_NAME = "ADMIN_KEY";
    const saved = localStorage.getItem(SAVED_KEY_NAME);
    if (saved) keyEl.value = saved;

    function setMsg(html) {
      msgEl.innerHTML = html || "";
    }

    function getAdminKey() {
      return (keyEl.value || "").trim();
    }

    saveKeyBtn.addEventListener("click", async () => {
      localStorage.setItem(SAVED_KEY_NAME, keyEl.value || "");
      setMsg(`<span class="ok">已記住密碼（只儲存在你部電腦瀏覽器）。</span>`);
      // 有 key 就嘗試載入「下期資料」
      try {
        await loadNextMetaIfPossible();
      } catch (e) {
        console.warn(e);
      }
    });

    // -------------------------
    // Basic helpers
    // -------------------------
    function parseNums(s) {
      return (s || "")
        .trim()
        .split(/[\s,，]+/)
        .filter(Boolean)
        .map(x => parseInt(x, 10))
        .filter(n => Number.isFinite(n) && n >= 1 && n <= 49);
    }

    function yearFromYMD(ymd) {
      const m = String(ymd || "").match(/^(\d{4})-/);
      return m ? parseInt(m[1], 10) : null;
    }

    function parseDrawNo(s) {
      s = String(s || "").trim();

      // 新格式：YY/XXX 例：25/018（允許 1-3 位 seq）
      let m = s.match(/^(\d{2})\s*\/\s*(\d{1,3})$/);
      if (m) {
        const yy = parseInt(m[1], 10);
        const seq = parseInt(m[2], 10);
        const yearFull = 2000 + yy; // assume 2000-2099
        return { yy, yearFull, seq };
      }

      // 舊格式：XXX/YYYY 例：018/2025
      m = s.match(/^(\d{1,3})\s*\/\s*(\d{4})$/);
      if (m) {
        const seq = parseInt(m[1], 10);
        const yearFull = parseInt(m[2], 10);
        const yy = yearFull % 100;
        return { yy, yearFull, seq };
      }

      return null;
    }

    function formatDrawNo(yearFull, seq) {
      const yy = String(yearFull % 100).padStart(2, "0");
      const s = String(seq).padStart(3, "0");
      return `${yy}/${s}`;
    }

    // -------------------------
    // Fetch helpers
    // -------------------------
    async function fetchJsonNoStore(url, init = {}) {
      const u = new URL(url, location.origin);
      u.searchParams.set("__ts", Date.now().toString()); // bust browser cache

      const res = await fetch(u.toString(), {
        cache: "no-store",
        headers: {
          accept: "application/json",
          ...(init.headers || {}),
        },
        ...init,
      });

      const text = await res.text();
      let data = {};
      try {
        data = text ? JSON.parse(text) : {};
      } catch (e) {
        throw new Error(`API 回傳非 JSON（HTTP ${res.status}）。前 200 字：` + text.slice(0, 200));
      }
      return { res, data };
    }

    // 對 /api/admin/* 一律帶兩種 header，避免後端驗證不一致造成 Unauthorized
    function buildAdminHeaders(extra = {}) {
      const key = getAdminKey();
      return {
        ...(key ? { "X-Admin-Key": key, "Authorization": `Bearer ${key}` } : {}),
        ...extra
      };
    }

    // 對同一 endpoint 嘗試多個 method（避免你 next.js 寫咗 PUT 但前端用 POST / 反之）
    async function adminJsonWithFallback(url, payload, methods) {
      const body = payload ? JSON.stringify(payload) : undefined;

      let lastErr = null;
      for (const method of methods) {
        try {
          const { res, data } = await fetchJsonNoStore(url, {
            method,
            headers: buildAdminHeaders({
              "content-type": "application/json",
            }),
            body,
          });

          // 有些後端會回 405 Method Not Allowed
          if (res.status === 405) {
            lastErr = new Error("Method Not Allowed");
            continue;
          }

          if (!res.ok || data?.ok !== true) {
            throw new Error(data?.error || `HTTP ${res.status}`);
          }

          return data;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error("Request failed");
    }

    // -------------------------
    // Next draw auto-calc
    // base can be:
    // 1) user-entered drawNoEl (if editing draw result)
    // 2) lastDraw from DB (if only updating next meta)
    // -------------------------
    let lastDraw = null;
    let drawNoTouched = false;

    function computeNextDrawNo() {
      const nd = (nextDrawDateEl.value || "").trim();
      const nextYearFull = yearFromYMD(nd);

      const base =
        parseDrawNo(drawNoEl.value) ||
        parseDrawNo(lastDraw?.drawNo) ||
        null;

      if (!nextYearFull || !base) {
        nextDrawNoEl.value = "";
        return;
      }

      if (nextYearFull === base.yearFull) {
        nextDrawNoEl.value = formatDrawNo(nextYearFull, base.seq + 1);
      } else {
        nextDrawNoEl.value = formatDrawNo(nextYearFull, 1);
      }
    }

    function updateJackpotHint() {
      const m = parseInt(nextJackpotMEl.value || "", 10);
      if (Number.isFinite(m) && m >= 0) {
        jackpotHintEl.textContent = `= 約 HK$ ${(m * 1000000).toLocaleString("en-US")}`;
      } else {
        jackpotHintEl.textContent = "";
      }
    }

    drawNoEl.addEventListener("input", () => {
      drawNoTouched = true;
      computeNextDrawNo();
    });

    drawDateEl.addEventListener("change", () => {
      // 如果用戶手動改過 drawNo，就唔自動覆蓋
      if (!lastDraw || drawNoTouched) return;

      const y = yearFromYMD(drawDateEl.value);
      const last = parseDrawNo(lastDraw.drawNo);
      const lastYearByDate = yearFromYMD(lastDraw.drawDate);
      const lastYearFull = Number.isFinite(lastYearByDate) ? lastYearByDate : (last ? last.yearFull : null);

      if (!y || !last || !lastYearFull) return;

      if (y === lastYearFull) drawNoEl.value = formatDrawNo(y, last.seq + 1);
      else drawNoEl.value = formatDrawNo(y, 1);

      prefillHintEl.textContent = `(已根據 DB 最新一期自動預填)`;
      computeNextDrawNo();
    });

    nextDrawDateEl.addEventListener("change", computeNextDrawNo);
    nextJackpotMEl.addEventListener("input", updateJackpotHint);

    // -------------------------
    // Prefill latest draw + optional next meta
    // -------------------------
    async function prefillLatestDraw() {
      try {
        // 1) try /api/draws?limit=1
        let { res, data } = await fetchJsonNoStore("/api/draws?limit=1");
        if (res.ok && data?.ok && Array.isArray(data.draws) && data.draws[0]?.drawNo) {
          lastDraw = data.draws[0];
          return;
        }

        // 2) fallback /api/latest
        ({ res, data } = await fetchJsonNoStore("/api/latest"));
        if (res.ok && data?.draw?.drawNo) {
          lastDraw = data.draw;
          // 兼容：有些 latest 會順便帶 nextDraw
          if (data?.nextDraw) {
            applyNextMetaFromAnyShape(data.nextDraw);
          }
          return;
        }
      } catch (e) {
        // ignore
      }
    }

    function applyNextMetaFromAnyShape(nextAny) {
      if (!nextAny) return;

      // 支援幾種常見命名
      const drawDate = nextAny.drawDate ?? nextAny.nextDrawDate ?? nextAny.date ?? null;
      const drawNo = nextAny.drawNo ?? nextAny.nextDrawNo ?? null;
      const jackpotM =
        nextAny.jackpotM ??
        nextAny.jackpotMillion ??
        nextAny.nextJackpotM ??
        nextAny.jackpot ??
        null;

      if (drawDate && !nextDrawDateEl.value) nextDrawDateEl.value = drawDate;
      if (drawNo && !nextDrawNoEl.value) nextDrawNoEl.value = drawNo;

      if ((jackpotM != null) && (nextJackpotMEl.value === "" || nextJackpotMEl.value == null)) {
        nextJackpotMEl.value = String(jackpotM);
      }

      updateJackpotHint();
      if (!nextDrawNoEl.value) computeNextDrawNo();
    }

    // /api/admin/next GET：如你後端支援，就會攞到「最準」嗰份下期資料
    async function loadNextMetaIfPossible() {
      const key = getAdminKey();
      if (!key) return;

      // 兼容：有些人 GET 要帶 key，有些唔要；我哋都帶上
      const { res, data } = await fetchJsonNoStore("/api/admin/next", {
        method: "GET",
        headers: buildAdminHeaders(),
      });

      if (!res.ok || data?.ok !== true) {
        // 唔阻 admin 用，只係 silent fail
        console.warn("loadNextMeta failed", data);
        return;
      }

      // 兼容你後端回傳 next / nextDraw / data.next
      applyNextMetaFromAnyShape(data.next || data.nextDraw || data.nextMeta || data);
    }

    // -------------------------
    // Submit: draw result upsert (ONLY)
    // -------------------------
    function validateDrawPayload(p) {
      if (!p.drawNo) return "請填「今期期數」。";
      if (!p.drawDate) return "請填「今期攪珠日期」。";
      if (!Array.isArray(p.numbers) || p.numbers.length !== 6) return "正選號碼必須剛好 6 個。";
      if (!Number.isFinite(p.special) || p.special < 1 || p.special > 49) return "特別號碼必須為 1–49。";
      return null;
    }

    async function submitDrawUpsert() {
      const key = getAdminKey();
      if (!key) {
        setMsg(`<span class="error">請先輸入密碼（ADMIN_KEY）。</span>`);
        return;
      }

      const payload = {
        drawNo: (drawNoEl.value || "").trim(),
        drawDate: drawDateEl.value || "",
        numbers: parseNums(numsEl.value || ""),
        special: parseInt(specialEl.value || "", 10),
      };

      const err = validateDrawPayload(payload);
      if (err) {
        setMsg(`<span class="error">失敗：${err}</span>`);
        return;
      }

      setMsg("提交中（更新攪珠結果）…");

      const { res, data } = await fetchJsonNoStore("/api/admin/upsert", {
        method: "POST",
        headers: buildAdminHeaders({
          "content-type": "application/json",
        }),
        body: JSON.stringify(payload),
      });

      if (!res.ok || data?.ok !== true) {
        setMsg(`<span class="error">失敗：${data?.error || ("HTTP " + res.status)}</span>`);
        return;
      }

      // Upsert success: update lastDraw so next auto calc becomes consistent
      lastDraw = { drawNo: payload.drawNo, drawDate: payload.drawDate };
      drawNoTouched = true;
      computeNextDrawNo();

      setMsg(`<span class="ok">✅ 攪珠結果更新成功！</span>`);
    }

    // -------------------------
    // Submit: next meta only (independent)
    // -------------------------
    async function submitNextOnly() {
      const key = getAdminKey();
      if (!key) {
        setMsg(`<span class="error">請先輸入密碼（ADMIN_KEY）。</span>`);
        return;
      }

      const nextDrawDate = (nextDrawDateEl.value || "").trim();
      if (!nextDrawDate) {
        setMsg(`<span class="error">請先填「下期攪珠日期」。</span>`);
        return;
      }

      // readonly；保險起見再計一次
      computeNextDrawNo();

      const nextDrawNo = (nextDrawNoEl.value || "").trim();
      if (!nextDrawNo) {
        setMsg(`<span class="error">未能自動計算「下期期數」。請先確保已有「今期期數」（或已成功讀取 DB 最新一期）。</span>`);
        return;
      }

      const nextJackpotM = nextJackpotMEl.value ? parseInt(nextJackpotMEl.value, 10) : null;

      // ✅ 同時送兩種 payload 形狀（flat + nested），確保 next.js 任何寫法都食到
      const payload = {
        nextDrawDate,
        nextDrawNo,
        nextJackpotM: Number.isFinite(nextJackpotM) ? nextJackpotM : null,
        next: {
          drawDate: nextDrawDate,
          drawNo: nextDrawNo,
          jackpotM: Number.isFinite(nextJackpotM) ? nextJackpotM : null,
        },
      };

      setMsg("提交中（只更新下期資料）…");

      // ✅ 兼容：你後端可能用 POST / PUT
      const data = await adminJsonWithFallback("/api/admin/next", payload, ["POST", "PUT"]);

      // 有些後端會回 {next:{...}} 或 {nextDraw:{...}}
      applyNextMetaFromAnyShape(data.next || data.nextDraw || data);

      setMsg(`<span class="ok">✅ 已更新下期資料（獨立）。</span>`);
    }

    // -------------------------
    // Wire buttons
    // -------------------------
    submitBtn.addEventListener("click", async () => {
      try {
        await submitDrawUpsert();
      } catch (e) {
        setMsg(`<span class="error">提交失敗：${e.message}</span>`);
      }
    });

    submitNextOnlyBtn.addEventListener("click", async () => {
      try {
        await submitNextOnly();
      } catch (e) {
        setMsg(`<span class="error">失敗：${e.message}</span>`);
      }
    });

    // -------------------------
    // Init
    // -------------------------
    (async function init() {
      updateJackpotHint();

      // 1) prefill latest draw (no auth)
      await prefillLatestDraw();

      // 2) auto prefill drawNo (only if empty)
      if (lastDraw?.drawNo && !drawNoEl.value) {
        const last = parseDrawNo(lastDraw.drawNo);
        const lastYearByDate = yearFromYMD(lastDraw.drawDate);
        const lastYearFull = Number.isFinite(lastYearByDate) ? lastYearByDate : (last ? last.yearFull : null);
        const todayYearFull = new Date().getFullYear();

        if (last && lastYearFull === todayYearFull) drawNoEl.value = formatDrawNo(todayYearFull, last.seq + 1);
        else drawNoEl.value = formatDrawNo(todayYearFull, 1);

        prefillHintEl.textContent = `(已根據 DB 最新一期自動預填；如跨年，改「攪珠日期」會自動修正)`;
      }

      // 3) compute next draw no if next date already selected
      computeNextDrawNo();

      // 4) if key exists, load next meta from /api/admin/next (auth)
      try {
        await loadNextMetaIfPossible();
        computeNextDrawNo();
      } catch (e) {
        // ignore
      }
    })();
  </script>
</body>
</html>
