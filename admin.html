<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mark6 管理頁</title>
  <style>
    body { font-family: system-ui, -apple-system, "PingFang HK", "Noto Sans TC", Arial, sans-serif; margin: 24px; line-height: 1.6; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 12px 0; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    input, button { padding: 8px 10px; }
    .muted { color:#666; font-size: 14px; }
    .error { color:#b00020; }
    .ok { color:#0a7a0a; }
    code { background:#f5f5f5; padding:2px 6px; border-radius:6px; }
    input[readonly] { background:#fafafa; }
  </style>
</head>
<body>
  <h1>Mark6 管理頁（寫入 D1）</h1>
  <p class="muted">提示：密碼你而家設為 <code>123456</code>（非常易被猜中，建議之後改長啲）。</p>

  <div class="card">
    <div class="row">
      <label>管理密碼</label>
      <input id="key" type="password" placeholder="123456" />
      <button id="saveKey">記住密碼</button>
    </div>

    <hr style="margin:14px 0;border:none;border-top:1px solid #eee;">

    <h3 style="margin:0 0 8px;">輸入今期攪珠結果</h3>

    <div class="row">
      <label>期數</label>
      <input id="drawNo" placeholder="例如：25/018" />
      <span class="muted" id="prefillHint"></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label>攪珠日期</label>
      <input id="drawDate" type="date" />
    </div>

    <div class="row" style="margin-top:10px;">
      <label>6 個號碼</label>
      <input id="nums" placeholder="例如：1 7 12 23 36 44" style="min-width: 320px;" />
      <label>特別號</label>
      <input id="special" type="number" min="1" max="49" style="width:90px;" />
    </div>

    <hr style="margin:14px 0;border:none;border-top:1px solid #eee;">

    <h3 style="margin:0 0 8px;">下期資料（可獨立更新）</h3>

    <div class="row">
      <label>下期攪珠日期</label>
      <input id="nextDrawDate" type="date" />
    </div>
    
    <div class="row" style="margin-top:10px;">
      <label>下期期數（自動）</label>
      <input id="nextDrawNo" readonly placeholder="會自動計算" />
      <span class="muted">同一年：+1；新一年：<code>001/新年份</code></span>
    </div>
    
    <div class="row" style="margin-top:10px;">
      <label>估計頭獎基金（百萬位）</label>
      <input id="nextJackpotM" type="number" min="0" step="1" style="width:120px;" placeholder="例如 22" />
      <span class="muted" id="jackpotHint"></span>
    </div>
    
    <div class="row" style="margin-top:14px;">
      <button id="submit">提交攪珠結果</button>
      <button id="submitNextOnly" type="button">只更新下期資料</button>
    </div>

    <div id="msg" class="muted" style="margin-top:12px;"></div>
  </div>

  <p><a href="/">返回首頁</a></p>

  <script>
    // =========================
    // Admin page script
    // - Draw result upsert: /api/admin/upsert  (X-Admin-Key)
    // - Next draw meta (independent): /api/admin/next (Authorization: Bearer <key>)
    // =========================
  
    const keyEl = document.getElementById("key");
    const msgEl = document.getElementById("msg");
  
    const drawNoEl = document.getElementById("drawNo");
    const drawDateEl = document.getElementById("drawDate");
  
    const nextDrawDateEl = document.getElementById("nextDrawDate");
    const nextDrawNoEl = document.getElementById("nextDrawNo");
    const nextJackpotMEl = document.getElementById("nextJackpotM");
  
    const prefillHintEl = document.getElementById("prefillHint");
    const jackpotHintEl = document.getElementById("jackpotHint");
  
    const numsEl = document.getElementById("nums");
    const specialEl = document.getElementById("special");
  
    const saveKeyBtn = document.getElementById("saveKey");
    const submitBtn = document.getElementById("submit");
  
    // -------------------------
    // Key storage
    // -------------------------
    const SAVED_KEY_NAME = "ADMIN_KEY";
    const saved = localStorage.getItem(SAVED_KEY_NAME);
    if (saved) keyEl.value = saved;
  
    function setMsg(html) {
      if (!msgEl) return;
      msgEl.innerHTML = html || "";
    }
  
    function getAdminKey() {
      return (keyEl?.value || "").trim();
    }
  
    if (saveKeyBtn) {
      saveKeyBtn.addEventListener("click", async () => {
        localStorage.setItem(SAVED_KEY_NAME, keyEl.value || "");
        setMsg(`<span class="ok">已記住密碼（只儲存在你部電腦瀏覽器）。</span>`);
        // 有 key 就嘗試載入已儲存的「下期資料」
        try {
          await loadNextMetaIfPossible();
        } catch (e) {
          // 不阻塞
          console.warn(e);
        }
      });
    }
  
    // -------------------------
    // Parsing helpers
    // -------------------------
    function parseNums(s) {
      return (s || "")
        .trim()
        .split(/[\s,，]+/)
        .filter(Boolean)
        .map((x) => parseInt(x, 10))
        .filter((n) => Number.isFinite(n) && n >= 1 && n <= 49);
    }
  
    function parseDrawNo(s) {
      s = String(s || "").trim();
  
      // 新格式：YY/XXX 例：25/018
      let m = s.match(/^(\d{2})\s*\/\s*(\d{1,3})$/);
      if (m) {
        const yy = parseInt(m[1], 10);
        const seq = parseInt(m[2], 10);
        const yearFull = 2000 + yy; // assume 2000-2099
        return { yy, yearFull, seq };
      }
  
      // 舊格式（兼容）：XXX/YYYY 例：018/2025
      m = s.match(/^(\d{1,3})\s*\/\s*(\d{4})$/);
      if (m) {
        const seq = parseInt(m[1], 10);
        const yearFull = parseInt(m[2], 10);
        const yy = yearFull % 100;
        return { yy, yearFull, seq };
      }
  
      return null;
    }
  
    function formatDrawNo(yearFull, seq) {
      const yy = String(yearFull % 100).padStart(2, "0");
      const s = String(seq).padStart(3, "0");
      return `${yy}/${s}`;
    }
  
    function yearFromYMD(ymd) {
      const m = String(ymd || "").match(/^(\d{4})-/);
      return m ? parseInt(m[1], 10) : null;
    }
  
    // -------------------------
    // Next draw auto-calc (base can be:
    // 1) user-entered drawNoEl (if editing current draw result)
    // 2) lastDraw from DB (if only updating next meta)
    // -------------------------
    let lastDraw = null;
    let drawNoTouched = false;
  
    function computeNextDrawNo() {
      const nd = (nextDrawDateEl?.value || "").trim(); // YYYY-MM-DD
      const nextYearFull = yearFromYMD(nd);
  
      const base =
        parseDrawNo(drawNoEl?.value) ||
        parseDrawNo(lastDraw?.drawNo) ||
        null;
  
      if (!nextYearFull || !base) {
        if (nextDrawNoEl) nextDrawNoEl.value = "";
        return;
      }
  
      if (nextYearFull === base.yearFull) {
        nextDrawNoEl.value = formatDrawNo(nextYearFull, base.seq + 1);
      } else {
        nextDrawNoEl.value = formatDrawNo(nextYearFull, 1); // 新一年 -> YY/001
      }
    }
  
    function updateJackpotHint() {
      const m = parseInt(nextJackpotMEl?.value || "", 10);
      if (Number.isFinite(m) && m >= 0) {
        if (jackpotHintEl) jackpotHintEl.textContent = `= 約 HK$ ${(m * 1000000).toLocaleString("en-US")}`;
      } else {
        if (jackpotHintEl) jackpotHintEl.textContent = "";
      }
    }
  
    if (drawNoEl) {
      drawNoEl.addEventListener("input", () => {
        drawNoTouched = true;
        computeNextDrawNo();
      });
    }
  
    if (drawDateEl) {
      drawDateEl.addEventListener("change", () => {
        // 如果用戶手動改過 drawNo，就唔自動覆蓋
        if (!lastDraw || drawNoTouched) return;
  
        const y = yearFromYMD(drawDateEl.value);
        const last = parseDrawNo(lastDraw.drawNo);
        const lastYearByDate = yearFromYMD(lastDraw.drawDate);
        const lastYearFull = Number.isFinite(lastYearByDate) ? lastYearByDate : (last ? last.yearFull : null);
  
        if (!y || !last || !lastYearFull) return;
  
        if (y === lastYearFull) {
          drawNoEl.value = formatDrawNo(y, last.seq + 1);
        } else {
          drawNoEl.value = formatDrawNo(y, 1);
        }
  
        if (prefillHintEl) prefillHintEl.textContent = `(已根據 DB 最新一期自動預填)`;
        computeNextDrawNo();
      });
    }
  
    if (nextDrawDateEl) nextDrawDateEl.addEventListener("change", computeNextDrawNo);
    if (nextJackpotMEl) nextJackpotMEl.addEventListener("input", updateJackpotHint);
  
    // -------------------------
    // Fetch helpers
    // -------------------------
    async function fetchJsonNoStore(url, init = {}) {
      const u = new URL(url, location.origin);
      u.searchParams.set("__ts", Date.now().toString()); // bust browser cache
  
      const res = await fetch(u.toString(), {
        cache: "no-store",
        headers: {
          accept: "application/json",
          ...(init.headers || {}),
        },
        ...init,
      });
  
      const text = await res.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch (e) {
        throw new Error(`API 回傳非 JSON（HTTP ${res.status}）。前 200 字：` + text.slice(0, 200));
      }
      return { res, data };
    }
  
    // -------------------------
    // Prefill: latest draw for convenience (no auth)
    // Prefer /api/draws?limit=1; fallback to /api/latest
    // -------------------------
    async function prefillLatestDraw() {
      try {
        // 1) try /api/draws
        let { res, data } = await fetchJsonNoStore("/api/draws?limit=1");
        if (res.ok && data?.ok && Array.isArray(data.draws) && data.draws[0]?.drawNo) {
          lastDraw = data.draws[0];
          return;
        }
  
        // 2) fallback /api/latest
        ({ res, data } = await fetchJsonNoStore("/api/latest"));
        if (res.ok && data?.draw?.drawNo) {
          lastDraw = data.draw;
          return;
        }
      } catch (e) {
        // ignore
      }
    }
  
    // -------------------------
    // Load next meta via /api/admin/next (needs auth)
    // -------------------------
    async function loadNextMetaIfPossible() {
      const key = getAdminKey();
      if (!key) return; // no key yet
  
      const { res, data } = await fetchJsonNoStore("/api/admin/next", {
        method: "GET",
        headers: { authorization: "Bearer " + key },
      });
  
      if (!res.ok || !data?.ok) {
        // 唔阻 admin 用，只係提示（通常係未輸入/輸入錯 key）
        console.warn("loadNextMeta failed", data);
        return;
      }
  
      const next = data.next || {};
      if (nextDrawDateEl && !nextDrawDateEl.value && next.drawDate) nextDrawDateEl.value = next.drawDate;
  
      // 如果 API 有存 drawNo，就用；否則會 auto compute
      if (nextDrawNoEl) nextDrawNoEl.value = next.drawNo || "";
  
      if (nextJackpotMEl && (nextJackpotMEl.value === "" || nextJackpotMEl.value == null)) {
        if (next.jackpotM != null) nextJackpotMEl.value = String(next.jackpotM);
      }
  
      updateJackpotHint();
      // 如果未有 stored drawNo，就用最新 drawNo + 日期 auto 計
      if (nextDrawNoEl && !nextDrawNoEl.value) computeNextDrawNo();
    }
  
    // -------------------------
    // Save next meta (independent)
    // -------------------------
    async function saveNextMetaOnly() {
      const key = getAdminKey();
      if (!key) {
        setMsg(`<span class="error">請先輸入密碼（ADMIN_KEY），再按「記住密碼」。</span>`);
        return;
      }
  
      const drawDate = (nextDrawDateEl?.value || "").trim();
      if (!drawDate) {
        setMsg(`<span class="error">請先填「下期攪珠日期」。</span>`);
        return;
      }
  
      // nextDrawNo is readonly; if empty, compute again
      if (nextDrawNoEl && !nextDrawNoEl.value) computeNextDrawNo();
  
      const drawNo = (nextDrawNoEl?.value || "").trim();
      if (!drawNo) {
        setMsg(`<span class="error">未能自動計算「下期期數」。請先確保已載入最新一期/或填「今期期數」再選下期日期。</span>`);
        return;
      }
  
      const jackpotM = nextJackpotMEl?.value ? parseInt(nextJackpotMEl.value, 10) : null;
      const payload = {
        next: {
          drawDate,
          drawNo,
          jackpotM: Number.isFinite(jackpotM) ? jackpotM : 0,
        },
      };
  
      setMsg(`提交中（只更新下期資料）…`);
  
      const { res, data } = await fetchJsonNoStore("/api/admin/next", {
        method: "PUT",
        headers: {
          authorization: "Bearer " + key,
          "content-type": "application/json",
        },
        body: JSON.stringify(payload),
      });
  
      if (!res.ok || !data?.ok) {
        setMsg(`<span class="error">失敗：${data?.error || ("HTTP " + res.status)}</span>`);
        return;
      }
  
      // refresh from server response
      const next = data.next || payload.next;
      if (nextDrawDateEl) nextDrawDateEl.value = next.drawDate || drawDate;
      if (nextDrawNoEl) nextDrawNoEl.value = next.drawNo || drawNo;
      if (nextJackpotMEl) nextJackpotMEl.value = String(next.jackpotM ?? jackpotM ?? "");
      updateJackpotHint();
  
      setMsg(`<span class="ok">✅ 已更新下期資料（獨立）。</span>`);
    }
  
    // -------------------------
    // Draw result upsert (does NOT write next meta anymore)
    // -------------------------
    function validateDrawPayload(p) {
      if (!p.drawNo) return "請填「今期期數」。";
      if (!p.drawDate) return "請填「今期攪珠日期」。";
      if (!Array.isArray(p.numbers) || p.numbers.length !== 6) return "正選號碼必須剛好 6 個。";
      if (!Number.isFinite(p.special) || p.special < 1 || p.special > 49) return "特別號碼必須為 1–49。";
      return null;
    }
  
    async function submitDrawUpsert() {
      const key = getAdminKey();
      if (!key) {
        setMsg(`<span class="error">請先輸入密碼（ADMIN_KEY），再按「記住密碼」。</span>`);
        return;
      }
  
      const payload = {
        drawNo: (drawNoEl?.value || "").trim(),
        drawDate: drawDateEl?.value || "",
        numbers: parseNums(numsEl?.value || ""),
        special: parseInt(specialEl?.value || "", 10),
      };
  
      const err = validateDrawPayload(payload);
      if (err) {
        setMsg(`<span class="error">失敗：${err}</span>`);
        return;
      }
  
      setMsg("提交中（更新攪珠結果）…");
  
      const { res, data } = await fetchJsonNoStore("/api/admin/upsert", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "X-Admin-Key": key,
        },
        body: JSON.stringify(payload),
      });
  
      if (!res.ok) {
        setMsg(`<span class="error">失敗：${data?.error || ("HTTP " + res.status)}</span>`);
        return;
      }
  
      // Upsert success: update lastDraw so next auto calc becomes consistent
      lastDraw = { drawNo: payload.drawNo, drawDate: payload.drawDate };
      drawNoTouched = true; // user updated it
      computeNextDrawNo();
  
      setMsg(`<span class="ok">✅ 攪珠結果更新成功！</span>`);
    }
  
    // -------------------------
    // UI: add an independent "update next" button beside existing submit
    // (no HTML changes needed)
    // -------------------------
    let submitNextBtn = null;
    function ensureNextOnlyButton() {
      if (!submitBtn || submitNextBtn) return;
  
      submitBtn.textContent = "提交攪珠結果";
  
      submitNextBtn = document.createElement("button");
      submitNextBtn.id = "submitNextOnly";
      submitNextBtn.type = "button";
      submitNextBtn.textContent = "只更新下期資料";
      submitNextBtn.style.marginLeft = "10px";
  
      submitBtn.insertAdjacentElement("afterend", submitNextBtn);
  
      submitNextBtn.addEventListener("click", async () => {
        try {
          await saveNextMetaOnly();
        } catch (e) {
          setMsg(`<span class="error">提交失敗：${e.message}</span>`);
        }
      });
    }
  
    // Existing submit => draw upsert only
    if (submitBtn) {
      submitBtn.addEventListener("click", async () => {
        try {
          await submitDrawUpsert();
        } catch (e) {
          setMsg(`<span class="error">提交失敗：${e.message}</span>`);
        }
      });
    }
  
    // -------------------------
    // Init
    // -------------------------
    (async function init() {
      ensureNextOnlyButton();
      updateJackpotHint();
  
      await prefillLatestDraw();
  
      // Auto prefill drawNo for convenience (only if empty)
      if (lastDraw?.drawNo && drawNoEl && !drawNoEl.value) {
        const last = parseDrawNo(lastDraw.drawNo);
        const lastYearByDate = yearFromYMD(lastDraw.drawDate);
        const lastYearFull = Number.isFinite(lastYearByDate) ? lastYearByDate : (last ? last.yearFull : null);
        const todayYearFull = new Date().getFullYear();
  
        if (last && lastYearFull === todayYearFull) {
          drawNoEl.value = formatDrawNo(todayYearFull, last.seq + 1);
        } else {
          drawNoEl.value = formatDrawNo(todayYearFull, 1);
        }
  
        if (prefillHintEl) {
          prefillHintEl.textContent = `(已根據 DB 最新一期自動預填；如跨年，改「攪珠日期」會自動修正)`;
        }
      }
  
      // Now that lastDraw exists, compute next draw no if next date already selected
      computeNextDrawNo();
  
      // Load stored next meta if key exists
      try {
        await loadNextMetaIfPossible();
        computeNextDrawNo();
      } catch (e) {
        // ignore
      }
    })();
  </script>

</body>
</html>
