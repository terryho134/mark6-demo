<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>中獎核對器｜Mark6</title>
  <style>
    body { font-family: system-ui, -apple-system, "PingFang HK", "Noto Sans TC", Arial, sans-serif; margin: 24px; line-height: 1.55; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .card { border:1px solid #ddd; border-radius:12px; padding:16px; margin:12px 0; }
    .muted { color:#666; font-size:14px; }
    .error { color:#b00020; }
    .ok { color:#0a7a0a; }
    input[type="checkbox"]{ padding:0; width:18px; height:18px; }
    .grid { display:grid; grid-template-columns: repeat(10, minmax(0, 1fr)); gap:6px; }
    .nbtn { padding:8px 0; border:1px solid #ddd; border-radius:10px; background:#fff; cursor:pointer; }
    .nbtn.on { background:#111; color:#fff; border-color:#111; }
    .nbtn.bank { background:#0b57d0; color:#fff; border-color:#0b57d0; }
    .nbtn.leg { background:#111; color:#fff; border-color:#111; }
    code { background:#f5f5f5; padding:2px 6px; border-radius:6px; }
    hr { border:none; border-top:1px solid #eee; margin:14px 0; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f3f3; font-size:13px; margin-right:6px; }
  </style>
</head>
<body>
  <h1>中獎核對器</h1>
  <p class="muted">支援：單式／複式／膽拖。頭/二/三獎派彩屬浮動，本頁只顯示「中獎份數」與固定獎金（四至七獎）。</p>

  <div class="card">
    <h3 style="margin-top:0;">1) 選擇玩法</h3>
    <div class="row">
      <label><input type="radio" name="type" value="single" checked> 單式</label>
      <label><input type="radio" name="type" value="multiple"> 複式</label>
      <label><input type="radio" name="type" value="banker"> 膽拖</label>
    </div>

    <hr>

    <h3 style="margin-top:0;">2) 選擇/輸入號碼</h3>
    <p class="muted" id="ruleHint"></p>

    <div class="row">
      <button id="clear">清除</button>
      <span class="pill" id="chancesPill">份數：—</span>
      <span class="pill" id="stakePill">投注額：—</span>
      <label id="halfWrap" style="margin-left:auto; display:inline-flex; align-items:center; gap:6px;">
        <input id="half" type="checkbox">
        半注（$5）
      </label>


    </div>

    <div style="margin-top:10px;">
      <div class="grid" id="grid"></div>
    </div>

    <div style="margin-top:12px;">
      <div class="muted">已選內容（可貼入/修改）：</div>
      <input id="input" style="width:100%;" placeholder="單式/複式：以空格分隔；膽拖：膽(空格) > 腳(空格)" />
      <div class="muted" style="margin-top:6px;">
        顯示格式：單式/複式 <code>1 7 12 23 36 44</code>；膽拖 <code>1 7 > 12 23 36 44 49</code>
      </div>
      <div id="inputErr" class="error" style="margin-top:6px;"></div>
    </div>

    <hr>

    <h3 style="margin-top:0;">3) 選填攪珠日期或期數</h3>
    <div class="row">
      <label>攪珠日期</label>
      <input id="drawDate" type="date" />

      <span class="muted">或</span>

      <label>期數</label>
      <select id="year"></select>
      <input id="seq" type="number" min="1" max="200" placeholder="例如 18" style="width:110px;">
      <span class="muted">→</span>
      <input id="drawNo" readonly placeholder="YY/XXX" style="width:100px;">
      <button id="clearDraw">清除期數/日期</button>
    </div>
    <div class="row" style="margin-top:10px;">
      <label>
        <input id="multiMode" type="checkbox">
        多期核對
      </label>
    
      <div id="multiControls" style="display:none;" class="row">
        <span class="muted">由</span>
        <select id="multiYear"></select>
        <select id="multiSeq"></select>
        <span class="muted">起，核對</span>
        <select id="multiCount">
          <option value="5">5期</option>
          <option value="10">10期</option>
          <option value="20">20期</option>
          <option value="30" selected>30期</option>
        </select>
        <span class="muted">（開始期：</span><input id="startDrawNo" readonly style="width:100px;" placeholder="YY/XXX"><span class="muted">）</span>
      </div>
    </div>

    <div class="muted">如同時填日期及期數，本頁會以 <strong>期數</strong> 優先。</div>

    <hr>

    <h3 style="margin-top:0;">4) 核對</h3>
    <div class="row">
      <button id="check">核對</button>
      <span id="status" class="muted"></span>
    </div>
  </div>

  <div class="card" id="resultCard" style="display:none;">
    <h3 style="margin:0;">結果</h3>

    <label id="rangeWrap" class="muted" style="margin-left:12px;">
      核對範圍：
      <select id="rangePreset">
        <option value="60days" selected>近60日</option>
        <option value="30draws">近30期</option>
        <option value="60draws">近60期</option>
      </select>
    </label>
    
    <label id="halfResultWrap" style="display:inline-flex; align-items:center; gap:6px;">
      <input id="halfResult" type="checkbox">
      半注（$5）
    </label>
  
    <div id="mainResult" style="margin-top:10px;"></div>
    <div id="recentBlock" style="margin-top:14px;"></div>
  </div>


  <p><a href="/">返回首頁</a></p>

  <script>
    // -------------------------
    // Helpers
    // -------------------------
    async function fetchJsonNoStore(url, fetchInit = {}) {
      const u = new URL(url, location.origin);
      // bust browser cache; edge cache key ignores __ts via canonicalizeUrl
      u.searchParams.set("__ts", Date.now().toString());
  
      const res = await fetch(u.toString(), {
        cache: "no-store",
        headers: {
          "Cache-Control": "no-cache",
          "accept": "application/json",
          ...(fetchInit.headers || {})
        },
        ...fetchInit,
      });
  
      const text = await res.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch (e) {
        throw new Error(`API 回傳非 JSON（HTTP ${res.status}）。前 200 字：` + text.slice(0, 200));
      }
      return { res, data };
    }
  
    function toNum(x, fallback = 0) {
      const n = Number(x);
      return Number.isFinite(n) ? n : fallback;
    }
  
    function parseNumsAny(x) {
      if (Array.isArray(x)) return x.map((v) => toNum(v)).filter((n) => n >= 1 && n <= 49);
      if (typeof x === "string") {
        return x
          .split(/[^0-9]+/)
          .filter(Boolean)
          .map((v) => toNum(v))
          .filter((n) => n >= 1 && n <= 49);
      }
      return [];
    }
  
    function getExtraNo(obj) {
      return (
        (Number.isFinite(Number(obj?.extra)) ? Number(obj.extra) : null) ??
        (Number.isFinite(Number(obj?.special)) ? Number(obj.special) : null) ??
        (Number.isFinite(Number(obj?.specialNo)) ? Number(obj.specialNo) : null) ??
        (Number.isFinite(Number(obj?.specialStr)) ? Number(obj.specialStr) : null) ??
        0
      );
    }
  
    function normalizeDrawNo(s) {
      const str = String(s || "").trim();
      // accept "26/2" -> "26/002"
      const m = str.match(/^(\d{2})\/(\d{1,3})$/);
      if (m) return `${m[1]}/${String(Number(m[2])).padStart(3, "0")}`;
      return str;
    }
  
    function normalizeDraw(d) {
      const nums =
        parseNumsAny(d.numbersArr).length ? parseNumsAny(d.numbersArr) :
        parseNumsAny(d.numbers).length ? parseNumsAny(d.numbers) :
        parseNumsAny(d.numbersStr);
  
      const sp = getExtraNo(d);
  
      return {
        drawNo: d.drawNo,
        drawNoN: normalizeDrawNo(d.drawNo),
        drawDate: d.drawDate,
        numbers: nums,
        extra: sp,
        special: sp,
      };
    }
  
    // -------------------------
    // Summary/Units extraction (server result may vary)
    // -------------------------
    function deriveSummaryFromUnitsFlexible(units) {
      if (!units) return [];
  
      const nameMap = {1:"頭獎",2:"二獎",3:"三獎",4:"四獎",5:"五獎",6:"六獎",7:"七獎"};
  
      // Case 1: array of prize objects
      if (Array.isArray(units)) {
        return units
          .map((p) => {
            const div = toNum(p.div ?? p.division ?? p.tier ?? p.prize ?? p.level, 0);
            const u = toNum(p.units ?? p.count ?? p.n ?? p.qty ?? p.value ?? 0, 0);
            if (div < 1 || div > 7 || u <= 0) return null;
            return { name: nameMap[div] || `第${div}獎`, units: u };
          })
          .filter(Boolean);
      }
  
      // Case 2: object map
      if (typeof units === "object") {
        const out = [];
        for (let div = 1; div <= 7; div++) {
          const keys = [
            `div${div}`,
            String(div),
            `d${div}`,
            `division${div}`,
            `tier${div}`,
            `prize${div}`,
            `level${div}`,
          ];
          let val = 0;
          for (const k of keys) {
            if (Number.isFinite(Number(units[k]))) { val = Number(units[k]); break; }
          }
          if (val > 0) out.push({ name: nameMap[div], units: val });
        }
        return out;
      }
  
      return [];
    }
  
    function summaryFromResult(r) {
      if (!r) return [];
  
      // 1) direct summary
      if (Array.isArray(r.summary) && r.summary.length) return r.summary;
  
      // 2) common arrays
      for (const key of ["prizes", "wins", "breakdown", "details"]) {
        if (Array.isArray(r[key]) && r[key].length) {
          const s = deriveSummaryFromUnitsFlexible(r[key]);
          if (s.length) return s;
  
          const s2 = r[key]
            .map(p => ({ name: p.name || p.title || "", units: toNum(p.units ?? p.count ?? 0, 0) }))
            .filter(x => x.units > 0 && x.name);
          if (s2.length) return s2;
        }
      }
  
      // 3) common objects
      const directCandidates = [
        "units",
        "prizeUnits",
        "divUnits",
        "divisionUnits",
        "divisions",
        "division",
        "prize",
        "prizeCount",
        "winUnits",
        "winCount",
        "counts",
      ];
  
      for (const k of directCandidates) {
        const s = deriveSummaryFromUnitsFlexible(r[k]);
        if (s.length) return s;
      }
  
      // 4) Deep scan nested
      const visited = new Set();
      function scan(obj, depth = 0) {
        if (!obj || typeof obj !== "object") return null;
        if (visited.has(obj)) return null;
        visited.add(obj);
  
        const sHere = deriveSummaryFromUnitsFlexible(obj);
        if (sHere.length) return sHere;
        if (depth >= 5) return null;
  
        if (Array.isArray(obj)) {
          for (const it of obj) {
            const s = scan(it, depth + 1);
            if (s && s.length) return s;
          }
          return null;
        }
  
        for (const key of Object.keys(obj)) {
          const val = obj[key];
          if (!val || typeof val !== "object") continue;
          const s = scan(val, depth + 1);
          if (s && s.length) return s;
        }
        return null;
      }
  
      const deep = scan(r, 0);
      if (deep && deep.length) return deep;
  
      return [];
    }
  
    function isWinResult(r) {
      if (!r) return false;
      if (r.anyWin === true || r.hasWin === true || r.won === true || r.isWin === true) return true;
  
      const s = summaryFromResult(r);
      if (s.length) return true;
  
      const units =
        r.units || r.prizeUnits || r.divUnits || r.divisionUnits || r.divisions || null;
  
      if (units && typeof units === "object") {
        for (const k of Object.keys(units)) {
          if (Number.isFinite(Number(units[k])) && Number(units[k]) > 0) return true;
        }
      }
      return false;
    }
  
    // merge draws/results returned by NEW API shape
    function mergeDrawsResults(draws = [], results = []) {
      return draws.map((d, i) => {
        const dn = normalizeDraw(d);
        const r = results[i] || {};
  
        const summary = summaryFromResult(r);
        const isWin = isWinResult(r);
  
        const fixedTotal =
          Number(r.fixedTotal ?? r.fixedAmount?.totalFixed ?? r.fixedAmount?.total ?? r.fixed) || 0;
  
        return {
          drawNo: dn.drawNo,
          drawNoN: dn.drawNoN,
          drawDate: dn.drawDate,
          numbers: dn.numbers,
          extra: dn.extra,
  
          summary,
          bestHit: r.bestHit,
          fixedTotal,
          topPrizeNote: r.topPrizeNote,
  
          isWin,
          __result: r,
        };
      });
    }
  
    // -------------------------
    // Client-side prize computation (ALWAYS accurate & independent from API shape)
    // -------------------------
    function intersectCount(aArr, bArr) {
      const b = new Set((bArr || []).map(Number));
      let c = 0;
      for (const x of (aArr || [])) if (b.has(Number(x))) c++;
      return c;
    }
  
    function choose(n, k) {
      n = Number(n); k = Number(k);
      if (k < 0 || n < 0 || k > n) return 0;
      k = Math.min(k, n - k);
      let r = 1;
      for (let i = 1; i <= k; i++) r = (r * (n - (k - i))) / i;
      return Math.round(r);
    }
  
    // Mark Six divisions (HKJC common):
    // 1: 6
    // 2: 5+special
    // 3: 5
    // 4: 4+special
    // 5: 4
    // 6: 3+special
    // 7: 3
    function unitsFromHit(mainHit, hitExtra) {
      const u = { div1:0, div2:0, div3:0, div4:0, div5:0, div6:0, div7:0 };
      if (mainHit === 6) u.div1 = 1;
      else if (mainHit === 5 && hitExtra) u.div2 = 1;
      else if (mainHit === 5) u.div3 = 1;
      else if (mainHit === 4 && hitExtra) u.div4 = 1;
      else if (mainHit === 4) u.div5 = 1;
      else if (mainHit === 3 && hitExtra) u.div6 = 1;
      else if (mainHit === 3) u.div7 = 1;
      return u;
    }
  
    function addUnits(a, b) {
      const out = { ...a };
      for (const k of Object.keys(out)) out[k] = (out[k] || 0) + (b[k] || 0);
      return out;
    }
  
    function sumUnits(units) {
      let s = 0;
      for (const k of Object.keys(units || {})) s += Number(units[k] || 0);
      return s;
    }
  
    function unitsToSummary(units) {
      const mapping = [
        ["div1","頭獎"],
        ["div2","二獎"],
        ["div3","三獎"],
        ["div4","四獎"],
        ["div5","五獎"],
        ["div6","六獎"],
        ["div7","七獎"],
      ];
      const out = [];
      for (const [k, name] of mapping) {
        const n = Number(units?.[k] || 0);
        if (n > 0) out.push({ name, units: n });
      }
      return out;
    }
  
    function bestHitFromUnits(units) {
      // find best by division priority
      if (units.div1) return { main: 6, extra: false };
      if (units.div2) return { main: 5, extra: true };
      if (units.div3) return { main: 5, extra: false };
      if (units.div4) return { main: 4, extra: true };
      if (units.div5) return { main: 4, extra: false };
      if (units.div6) return { main: 3, extra: true };
      if (units.div7) return { main: 3, extra: false };
      return null;
    }
  
    function computeUnitsSingle(numbers, drawNumbers, drawExtra) {
      const mainHit = intersectCount(numbers, drawNumbers);
      const hitExtra = (numbers || []).map(Number).includes(Number(drawExtra));
      return { units: unitsFromHit(mainHit, hitExtra), bestHit: { main: mainHit, extra: hitExtra } };
    }
  
    function computeUnitsMultiple(picks, drawNumbers, drawExtra) {
      // formula approach:
      // let m = main matches among picks
      // let s = whether extra in picks
      // remaining picks not in draw main: r = picksCount - m - (s?1:0 if extra not in main)
      const p = (picks || []).map(Number);
      const drawMain = (drawNumbers || []).map(Number);
      const m = intersectCount(p, drawMain);
      const s = p.includes(Number(drawExtra));
      const n = p.length;
  
      // pick main numbers for a bet: 6 numbers
      // cases:
      // div1: choose m,6
      // div2: choose m,5 * choose(n-m,1 extra) but needs that chosen 1 is the special; easier:
      // choose m,5 * (s?1:0)  (because special must be included)
      // div3: choose m,5 * choose(n-m-(s?1:0),1) where the 1 is not special
      // Similarly:
      // div4: choose m,4 * (s?1:0) * choose(othersNotMainNotSpecial,1)
      // div5: choose m,4 * choose(othersNotMain,2) but exclude cases where special is included? handle explicitly.
      //
      // We will count each division by considering chosen set composition:
      // Let x = #main chosen, y = whether special chosen (0/1), z = remaining non-main chosen
      // with x + y + z = 6
      // z is chosen from pool "others" size o where:
      // o = n - m - (s ? 1 : 0)  (exclude main matches and special)
      const o = n - m - (s ? 1 : 0);
  
      const u = { div1:0, div2:0, div3:0, div4:0, div5:0, div6:0, div7:0 };
  
      // div1: 6 main
      u.div1 = choose(m, 6);
  
      // div2: 5 main + special + 0 other
      u.div2 = s ? choose(m, 5) * choose(o, 0) : 0;
  
      // div3: 5 main + 0 special + 1 other
      u.div3 = choose(m, 5) * choose(o, 1);
  
      // div4: 4 main + special + 1 other
      u.div4 = s ? choose(m, 4) * choose(o, 1) : 0;
  
      // div5: 4 main + 0 special + 2 other
      u.div5 = choose(m, 4) * choose(o, 2);
  
      // div6: 3 main + special + 2 other
      u.div6 = s ? choose(m, 3) * choose(o, 2) : 0;
  
      // div7: 3 main + 0 special + 3 other
      u.div7 = choose(m, 3) * choose(o, 3);
  
      // best hit (approx): use max main hit and whether special is selectable
      // but for display we prefer per-draw actual bestHit among all combinations is:
      // if any div exists then map best division to its (main,extra), else show max mainHit & special hit
      const best = bestHitFromUnits(u) || { main: m, extra: s };
  
      return { units: u, bestHit: best };
    }
  
    function computeUnitsBanker(bankers, legs, drawNumbers, drawExtra) {
      const b = (bankers || []).map(Number);
      const l = (legs || []).map(Number);
      const drawMain = (drawNumbers || []).map(Number);
      const extra = Number(drawExtra);
  
      const bHit = intersectCount(b, drawMain);
      const lHit = intersectCount(l, drawMain);
      const bHasExtra = b.includes(extra);
      const lHasExtra = l.includes(extra);
  
      const bCount = b.length;
      const lCount = l.length;
      const needFromLeg = 6 - bCount;
  
      // total combinations = choose(lCount, needFromLeg)
      // for each bet:
      // mainHit = bHit + x where x is how many of selected legs are in drawMain
      // extraHit = if extra is in bankers OR in selected legs
      //
      // count distributions:
      // choose x legs from lHit (hit in main), and remaining from lCount - lHit - (lHasExtra?1:0?) ...
      // We treat extra as separate from main pool. We'll compute counts by cases whether selected includes extra (if available in legs) and whether already in bankers.
      const u = { div1:0, div2:0, div3:0, div4:0, div5:0, div6:0, div7:0 };
  
      const legsMainHit = lHit;
      const legsMainMiss = lCount - legsMainHit - (lHasExtra ? 1 : 0);
      const legsExtraAvail = lHasExtra ? 1 : 0;
  
      for (let takeExtra = 0; takeExtra <= legsExtraAvail; takeExtra++) {
        const remainingPick = needFromLeg - takeExtra;
        if (remainingPick < 0) continue;
  
        for (let x = 0; x <= remainingPick; x++) {
          // x from legsMainHit
          // remainingPick-x from legsMainMiss
          const ways =
            choose(legsMainHit, x) * choose(legsMainMiss, remainingPick - x);
  
          if (!ways) continue;
  
          const mainHit = bHit + x;
          const hitExtra = bHasExtra || (takeExtra === 1);
  
          const add = unitsFromHit(mainHit, hitExtra);
          // multiply by ways
          for (const k of Object.keys(u)) u[k] += (add[k] || 0) * ways;
        }
      }
  
      // bestHit for display: if any div exists -> map best division
      const best = bestHitFromUnits(u) || { main: (bHit + lHit), extra: (bHasExtra || lHasExtra) };
      return { units: u, bestHit: best };
    }
  
    function computeUnitsClient(ticket, draw) {
      const t = ticket || {};
      const dn = (draw?.numbers || []).map(Number);
      const ex = Number(draw?.extra || draw?.special || 0);
  
      let units = { div1:0, div2:0, div3:0, div4:0, div5:0, div6:0, div7:0 };
      let bestHit = null;
  
      if (t.type === "banker") {
        const out = computeUnitsBanker(t.bankers || [], t.legs || t.others || [], dn, ex);
        units = out.units; bestHit = out.bestHit;
      } else if (t.type === "multiple") {
        const out = computeUnitsMultiple(t.picks || t.numbers || t.nums || [], dn, ex);
        units = out.units; bestHit = out.bestHit;
      } else {
        const out = computeUnitsSingle(t.picks || t.numbers || t.nums || [], dn, ex);
        units = out.units; bestHit = out.bestHit;
      }
  
      const summary = unitsToSummary(units);
      return { units, summary, bestHit };
    }
  
    // -------------------------
    // DOM refs
    // -------------------------
    const rangeEl = document.getElementById("rangePreset");
    const rangeWrapEl = document.getElementById("rangeWrap");
  
    const multiModeEl = document.getElementById("multiMode");
    const multiControlsEl = document.getElementById("multiControls");
    const multiYearEl = document.getElementById("multiYear");
    const multiSeqEl = document.getElementById("multiSeq");
    const multiCountEl = document.getElementById("multiCount");
    const startDrawNoEl = document.getElementById("startDrawNo");
  
    const gridEl = document.getElementById("grid");
    const inputEl = document.getElementById("input");
    const inputErrEl = document.getElementById("inputErr");
    const ruleHintEl = document.getElementById("ruleHint");
    const chancesPill = document.getElementById("chancesPill");
    const stakePill = document.getElementById("stakePill");
    const halfEl = document.getElementById("half");
    const halfResultEl = document.getElementById("halfResult");
    const halfWrapEl = document.getElementById("halfWrap");
    const halfResultWrapEl = document.getElementById("halfResultWrap");
  
    const drawDateEl = document.getElementById("drawDate");
    const yearEl = document.getElementById("year");
    const seqEl = document.getElementById("seq");
    const drawNoEl = document.getElementById("drawNo");
  
    const statusEl = document.getElementById("status");
    const resultCard = document.getElementById("resultCard");
    const mainResultEl = document.getElementById("mainResult");
    const recentBlockEl = document.getElementById("recentBlock");
  
    const typeEls = Array.from(document.querySelectorAll('input[name="type"]'));
  
    // -------------------------
    // state
    // -------------------------
    let type = "single";
    let picks = new Set();
    let bankers = new Set();
    let legs = new Set();
  
    function updateHalfVisibility(){
      const show = (type !== "single"); // 單式：唔顯示半注
      if (!show) {
        halfEl.checked = false;
        if (halfResultEl) halfResultEl.checked = false;
      }
      if (halfWrapEl) halfWrapEl.style.display = show ? "inline-flex" : "none";
      if (halfResultWrapEl) halfResultWrapEl.style.display = show ? "inline-flex" : "none";
    }
  
    function updateRangeVisibility(){
      const hasSingleTarget = !!drawDateEl.value || !!drawNoEl.value;
      const isMulti = (multiModeEl ? multiModeEl.checked : false);
      const show = !hasSingleTarget && !isMulti;
      if (rangeWrapEl) rangeWrapEl.style.display = show ? "inline-flex" : "none";
    }
  
    function pad2(x){ return String(x).padStart(2,"0"); }
    function pad3(x){ return String(x).padStart(3,"0"); }
    function yyFromYear(y){ return pad2(Number(y)%100); }
  
    function buildDrawNoFromYearSeq(){
      const y = yearEl.value;
      const seq = parseInt(seqEl.value,10);
      if(!y || !Number.isFinite(seq) || seq<=0) { drawNoEl.value=""; return; }
      drawNoEl.value = `${yyFromYear(y)}/${pad3(seq)}`;
      updateRangeVisibility();
    }
  
    // years dropdown
    (function initYears(){
      const nowY = new Date().getFullYear();
      for(let y=2002; y<=nowY; y++){
        const opt=document.createElement("option");
        opt.value=String(y);
        opt.textContent=String(y);
        yearEl.appendChild(opt);
      }
      yearEl.value=String(nowY);
    })();
  
    (function initMulti(){
      const nowY = new Date().getFullYear();
      for(let y=2002; y<=nowY; y++){
        const opt=document.createElement("option");
        opt.value=String(y);
        opt.textContent=String(y);
        multiYearEl.appendChild(opt);
      }
      multiYearEl.value=String(nowY);
  
      for(let i=1;i<=200;i++){
        const opt=document.createElement("option");
        opt.value=String(i);
        opt.textContent=String(i).padStart(3,"0");
        multiSeqEl.appendChild(opt);
      }
      multiSeqEl.value="1";
  
      function buildStartDrawNo(){
        const y = multiYearEl.value;
        const s = parseInt(multiSeqEl.value,10);
        if(!y || !Number.isFinite(s) || s<=0){ startDrawNoEl.value=""; return; }
        startDrawNoEl.value = `${yyFromYear(y)}/${pad3(s)}`;
      }
  
      multiYearEl.addEventListener("change", buildStartDrawNo);
      multiSeqEl.addEventListener("change", buildStartDrawNo);
      buildStartDrawNo();
    })();
  
    function setMultiMode(on){
      multiControlsEl.style.display = on ? "flex" : "none";
  
      drawDateEl.disabled = on;
      yearEl.disabled = on;
      seqEl.disabled = on;
      document.getElementById("clearDraw").disabled = on;
  
      if (on) {
        drawDateEl.value="";
        seqEl.value="";
        drawNoEl.value="";
        updateRangeVisibility();
      }
    }
  
    if (multiModeEl) {
      multiModeEl.addEventListener("change", ()=>{
        setMultiMode(multiModeEl.checked);
        updateRangeVisibility();
      });
    }
  
    yearEl.addEventListener("change", buildDrawNoFromYearSeq);
    seqEl.addEventListener("input", buildDrawNoFromYearSeq);
    drawDateEl.addEventListener("change", updateRangeVisibility);
  
    document.getElementById("clearDraw").addEventListener("click", ()=>{
      drawDateEl.value="";
      seqEl.value="";
      drawNoEl.value="";
      updateRangeVisibility();
    });
  
    // range + multiCount change should re-check
    if (rangeEl) {
      rangeEl.addEventListener("change", ()=>{
        if(resultCard.style.display !== "none") runCheck();
      });
    }
    if (multiCountEl) {
      multiCountEl.addEventListener("change", ()=>{
        if(resultCard.style.display !== "none") runCheck();
      });
    }
  
    // grid buttons 1..49
    function makeGrid(){
      gridEl.innerHTML="";
      for(let i=1;i<=49;i++){
        const b=document.createElement("button");
        b.type="button";
        b.className="nbtn";
        b.textContent=String(i).padStart(2,"0");
        b.dataset.n=String(i);
        b.addEventListener("click", ()=>toggleNumber(i));
        gridEl.appendChild(b);
      }
    }
    makeGrid();
  
    function setType(newType){
      type=newType;
      picks=new Set(); bankers=new Set(); legs=new Set();
      inputEl.value="";
      inputErrEl.textContent="";
      updateHint();
      renderGrid();
      updateChancesStake();
      updateHalfVisibility();
    }
  
    function updateHint(){
      if(type==="single") ruleHintEl.textContent="單式：必須選 6 個號碼。";
      if(type==="multiple") ruleHintEl.textContent="複式：最少 7 個號碼。";
      if(type==="banker") ruleHintEl.textContent="膽拖：先點「膽」(最多 5 個)，再點「腳」。總數需 ≥7。";
    }
  
    typeEls.forEach(r=>{
      r.addEventListener("change", ()=>{
        if(r.checked) setType(r.value);
      });
    });
  
    function toggleNumber(n){
      if(type==="single" || type==="multiple"){
        if(picks.has(n)) picks.delete(n);
        else picks.add(n);
        syncInputFromState();
        renderGrid();
        updateChancesStake();
        return;
      }
  
      // banker mode: off -> banker -> leg -> off
      if(bankers.has(n)){
        bankers.delete(n);
        legs.add(n);
      } else if(legs.has(n)){
        legs.delete(n);
      } else {
        if(bankers.size < 5) bankers.add(n);
        else legs.add(n);
      }
      for(const x of bankers) if(legs.has(x)) legs.delete(x);
  
      syncInputFromState();
      renderGrid();
      updateChancesStake();
    }
  
    function renderGrid(){
      const btns = gridEl.querySelectorAll(".nbtn");
      btns.forEach(b=>{
        const n = parseInt(b.dataset.n,10);
        b.classList.remove("on","bank","leg");
        if(type==="single" || type==="multiple"){
          if(picks.has(n)) b.classList.add("on");
        } else {
          if(bankers.has(n)) b.classList.add("bank");
          else if(legs.has(n)) b.classList.add("leg");
        }
      });
    }
  
    function syncInputFromState(){
      if(type==="single" || type==="multiple"){
        const arr = Array.from(picks).sort((a,b)=>a-b);
        inputEl.value = arr.join(" ");
        return;
      }
      const b = Array.from(bankers).sort((a,b)=>a-b).join(" ");
      const l = Array.from(legs).sort((a,b)=>a-b).join(" ");
      inputEl.value = (b || l) ? `${b} > ${l}`.trim() : "";
    }
  
    function parseInputToState(){
      const raw = (inputEl.value || "").trim();
      inputErrEl.textContent="";
      if(!raw){
        if(type==="single"||type==="multiple") picks=new Set();
        else { bankers=new Set(); legs=new Set(); }
        return true;
      }
  
      const numsFromPart = (s)=> s.trim().split(/[\s,，]+/).filter(Boolean).map(x=>parseInt(x,10)).filter(n=>Number.isFinite(n));
  
      if(type==="banker"){
        const parts = raw.split(">");
        const left = parts[0] ?? "";
        const right = parts[1] ?? "";
        const b = numsFromPart(left);
        const l = numsFromPart(right);
  
        const bset = new Set(b);
        const lset = new Set(l);
        for(const x of bset) if(lset.has(x)) lset.delete(x);
  
        bankers = new Set(Array.from(bset).filter(n=>n>=1 && n<=49));
        legs = new Set(Array.from(lset).filter(n=>n>=1 && n<=49));
        return validateAndShow(false);
      } else {
        const arr = numsFromPart(raw).filter(n=>n>=1 && n<=49);
        picks = new Set(arr);
        return validateAndShow(false);
      }
    }
  
    function validateAndShow(showError=true){
      const half = (type==="single") ? false : halfEl.checked;
      const unitStake = half ? 5 : 10;
  
      if(type==="single"){
        if(picks.size!==6){
          if(showError) inputErrEl.textContent="單式需要剛好 6 個號碼。";
          updateChancesStake(0, unitStake);
          return false;
        }
        updateChancesStake(1, unitStake);
        return true;
      }
  
      if(type==="multiple"){
        if(picks.size<7){
          if(showError) inputErrEl.textContent="複式需要最少 7 個號碼。";
          updateChancesStake(0, unitStake);
          return false;
        }
        const chances = choose(picks.size,6);
        updateChancesStake(chances, unitStake);
        return true;
      }
  
      if(bankers.size<1 || bankers.size>5){
        if(showError) inputErrEl.textContent="膽拖：膽需要 1–5 個。";
        updateChancesStake(0, unitStake);
        return false;
      }
      if(bankers.size + legs.size < 7){
        if(showError) inputErrEl.textContent="膽拖：總數需 ≥ 7（膽 + 腳）。";
        updateChancesStake(0, unitStake);
        return false;
      }
      const t = 6 - bankers.size;
      if(legs.size < t){
        if(showError) inputErrEl.textContent=`膽拖：腳不足以補足 6 個號碼（需要至少 ${t} 個腳）。`;
        updateChancesStake(0, unitStake);
        return false;
      }
      const chances = choose(legs.size, t);
      updateChancesStake(chances, unitStake);
      return true;
    }
  
    function updateChancesStake(chances=null, unitStake=null){
      const half = (type==="single") ? false : halfEl.checked;
      const u = unitStake ?? (half ? 5 : 10);
  
      let c = chances;
      if(c===null){
        if(type==="single") c = (picks.size===6) ? 1 : 0;
        else if(type==="multiple") c = (picks.size>=7) ? choose(picks.size,6) : 0;
        else {
          const t = 6 - bankers.size;
          c = (bankers.size>=1 && bankers.size<=5 && legs.size>=t) ? choose(legs.size,t) : 0;
        }
      }
  
      chancesPill.textContent = `份數：${c ? c.toLocaleString("en-US") : "—"}`;
      stakePill.textContent = `投注額：${c ? "HK$ " + (c*u).toLocaleString("en-US") : "—"}`;
    }
  
    document.getElementById("clear").addEventListener("click", ()=>{
      picks=new Set(); bankers=new Set(); legs=new Set();
      inputEl.value="";
      inputErrEl.textContent="";
      renderGrid();
      updateChancesStake();
    });
  
    inputEl.addEventListener("input", ()=>{
      parseInputToState();
      renderGrid();
      updateChancesStake();
    });
  
    let syncingHalf = false;
    function syncHalfUI(from) {
      if (syncingHalf) return;
      syncingHalf = true;
      const v = from.checked;
      halfEl.checked = v;
      if (halfResultEl) halfResultEl.checked = v;
      syncingHalf = false;
    }
  
    halfEl.addEventListener("change", ()=>{
      syncHalfUI(halfEl);
      updateChancesStake();
      if(resultCard.style.display !== "none") runCheck();
    });
  
    if (halfResultEl) {
      halfResultEl.addEventListener("change", ()=>{
        syncHalfUI(halfResultEl);
        updateChancesStake();
        if(resultCard.style.display !== "none") runCheck();
      });
    }
  
    // -------------------------
    // IMPORTANT: make payload match API expected shape
    // -------------------------
    function buildScope(){
      // Multi mode first
      if (multiModeEl && multiModeEl.checked) {
        return {
          multi: true,
          startDrawNo: startDrawNoEl.value.trim(),
          multiCount: toNum(multiCountEl.value, 10) || 10,
        };
      }
  
      const drawNo = (drawNoEl.value || "").trim();
      const drawDate = (drawDateEl.value || "").trim();
  
      if (drawNo) return { drawNo };
      if (drawDate) return { drawDate };
  
      const rp = rangeEl ? rangeEl.value : "60days";
  
      // legacy-compatible expansion
      const legacy = {};
      if (rp === "60days") legacy.days = 60;
      if (rp === "30issues") legacy.issues = 30;
      if (rp === "60issues") legacy.issues = 60;
  
      return { rangePreset: rp, ...legacy };
    }
  
    function buildTicket(){
      const half = (type==="single") ? false : !!halfEl.checked;
  
      if(type==="single"){
        return { type: "single", half, picks: Array.from(picks).sort((a,b)=>a-b) };
      }
      if(type==="multiple"){
        return { type: "multiple", half, picks: Array.from(picks).sort((a,b)=>a-b) };
      }
      return {
        type: "banker",
        half,
        bankers: Array.from(bankers).sort((a,b)=>a-b),
        legs: Array.from(legs).sort((a,b)=>a-b),
      };
    }
  
    function buildApiPayload(){
      const ticket = buildTicket();
      const scope = buildScope();
  
      const picksArr = Array.isArray(ticket.picks) ? ticket.picks : [];
      const bankersArr = Array.isArray(ticket.bankers) ? ticket.bankers : [];
      const legsArr = Array.isArray(ticket.legs) ? ticket.legs : [];
  
      const bets =
        ticket.type === "banker"
          ? [{ type: "banker", bankers: bankersArr, others: legsArr }]
          : ticket.type === "multiple"
          ? [{ type: "multiple", numbers: picksArr }]
          : [{ type: "single", numbers: picksArr }];
  
      return {
        // Newer shape
        bets,
        half: !!ticket.half,
        scope,
  
        // Legacy flat keys
        type: ticket.type,
        halfBet: !!ticket.half,
        picks: picksArr,
        numbers: picksArr,
        nums: picksArr,
        bankers: bankersArr,
        legs: legsArr,
        others: legsArr,
  
        // Legacy nested object
        ticket: {
          type: ticket.type,
          half: !!ticket.half,
          picks: picksArr,
          numbers: picksArr,
          nums: picksArr,
          bankers: bankersArr,
          legs: legsArr,
          others: legsArr,
        },
  
        // Query/scope keys
        ...scope,
      };
    }
  
    function fmtYMD(ymd){
      if(!ymd) return "";
      const m = String(ymd).match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if(!m) return ymd;
      return `${m[1]}年${m[2]}月${m[3]}日`;
    }
  
    function scopeToLabel(scope = {}) {
      if (scope.drawNo) return `指定期數：${normalizeDrawNo(scope.drawNo)}`;
      if (scope.drawDate) return `指定日期：${scope.drawDate}`;
      if (scope.rangePreset === "60days" || scope.days === 60) return "近60日";
      if (scope.rangePreset === "30issues" || scope.issues === 30) return "近30期";
      if (scope.rangePreset === "60issues" || scope.issues === 60) return "近60期";
      if (scope.days) return `近${scope.days}日`;
      if (scope.issues) return `近${scope.issues}期`;
      return "最近範圍";
    }
  
    function renderSingleComputed(ticket, item, label) {
      const dNumbers = (item.numbers || []).map(Number);
      const dExtra = Number(item.extra || 0);
  
      const computed = computeUnitsClient(ticket, { numbers: dNumbers, extra: dExtra });
      const summary = computed.summary || [];
      const hit = computed.bestHit || item.bestHit;
  
      const half = !!ticket.half;
      const unitStake = half ? 5 : 10;
      let chances = 0;
      if (ticket.type === "single") chances = 1;
      else if (ticket.type === "multiple") chances = choose((ticket.picks || []).length, 6);
      else chances = choose((ticket.legs || []).length, 6 - (ticket.bankers || []).length);
  
      const totalStake = chances * unitStake;
  
      const lines = [];
      lines.push(`<div class="muted">核對範圍：${label}</div>`);
      lines.push(`<div style="margin-top:6px;"><strong>攪珠：</strong>${normalizeDrawNo(item.drawNo)}（${fmtYMD(item.drawDate)}）</div>`);
      lines.push(`<div class="muted">正選：${dNumbers.join(" ")}　特別號：${String(dExtra).padStart(2,"0")}</div>`);
      lines.push(`<div style="margin-top:8px;"><strong>你的彩票：</strong>${ticket.type}｜份數 ${chances.toLocaleString("en-US")}｜每份 HK$${unitStake}｜投注額 HK$ ${totalStake.toLocaleString("en-US")}</div>`);
  
      if (!summary.length) {
        const hitText = hit ? `命中：${hit.main}個正選${hit.extra ? " + 特別號" : ""}` : "";
        lines.push(`<div style="margin-top:10px;"><strong>結果：</strong>未中獎</div>`);
        if (hitText) lines.push(`<div class="muted" style="margin-top:6px;">${hitText}（未中獎）</div>`);
        return lines.join("");
      }
  
      const summaryText = summary.map(x=>`${x.name} × ${toNum(x.units,0).toLocaleString("en-US")}`).join("，");
      lines.push(`<div style="margin-top:10px;"><strong>中獎：</strong>${summaryText}</div>`);
      return lines.join("");
    }
  
    function renderRecent(wins, titleLabel="近60日"){
      const title = `${titleLabel}（只顯示有中獎）`;
  
      const list = (wins || []).map(w => {
        const summary = Array.isArray(w.summary) ? w.summary : summaryFromResult(w.__result || w);
        const isWin = (w.isWin === true) || (summary.length > 0) || isWinResult(w.__result || w);
        const extra = Number.isFinite(Number(w.extra)) ? Number(w.extra) : getExtraNo(w);
        const numbers = Array.isArray(w.numbers) ? w.numbers.map(Number) : parseNumsAny(w.numbers);
  
        return { ...w, summary, isWin, extra, numbers };
      });
  
      const onlyWins = list.filter(w => w.isWin);
  
      if(onlyWins.length === 0){
        return `<h4 style="margin:0 0 8px;">${title}</h4><div class="muted">未有中獎紀錄。</div>`;
      }
  
      const items = onlyWins.map(w=>{
        const sArr = (w.summary || []);
        const s = sArr.length
          ? sArr.map(x=>`${x.name}×${x.units}`).join("，")
          : "中獎（獎項明細未提供）";
  
        const fixed = w.fixedTotal ? `｜固定獎金 HK$ ${Number(w.fixedTotal).toLocaleString("en-US")}` : "";
        const note = w.topPrizeNote ? `｜${w.topPrizeNote}` : "";
  
        const hit = w.bestHit;
        const hitText = hit
          ? `命中：${hit.main}個正選${hit.extra ? " + 特別號" : ""}`
          : "";
  
        const nums = (w.numbers && w.numbers.length)
          ? `正選：${w.numbers.join(" ")}　特別號：${String(w.extra).padStart(2,"0")}`
          : "";
  
        return `
          <li style="margin:10px 0;">
            <div><strong>${normalizeDrawNo(w.drawNo)}</strong>（${fmtYMD(w.drawDate)}）：${s}${fixed}${note}</div>
            ${hitText ? `<div class="muted">${hitText}</div>` : ""}
            ${nums ? `<div class="muted">${nums}</div>` : ""}
          </li>
        `;
      }).join("");
  
      return `<h4 style="margin:0 0 8px;">${title}</h4><ol>${items}</ol>`;
    }
  
    // -------------------------
    // Run check
    // -------------------------
    async function runCheck(){
      inputErrEl.textContent="";
      const ok = validateAndShow(true);
      if(!ok) return;
  
      statusEl.textContent="核對中…";
  
      resultCard.style.display = "block";
      if (halfResultEl) halfResultEl.checked = halfEl.checked;
  
      mainResultEl.innerHTML = `<div class="muted">核對中…</div>`;
      recentBlockEl.innerHTML = "";
  
      const payload = buildApiPayload();
      const effectiveScope = payload.scope || buildScope();
      console.log("[check] payload", payload);
  
      try{
        const { res, data } = await fetchJsonNoStore("/api/check", {
          method: "POST",
          headers: { "content-type":"application/json" },
          body: JSON.stringify(payload),
        });
  
        console.log("[check] response keys", Object.keys(data || {}), data);
  
        if(!res.ok || !data.ok){
          statusEl.textContent="";
          const msg = data.error || ("HTTP " + res.status);
          inputErrEl.textContent = msg;
          mainResultEl.innerHTML = `<div class="error">核對失敗：${msg}</div>`;
          return;
        }
  
        statusEl.textContent="";
        resultCard.style.display="block";
        if (halfResultEl) halfResultEl.checked = halfEl.checked;
  
        // -------------------------
        // ✅ NEW API SHAPE:
        // { draws: [...], results: [...], meta: { scope, drawCount }, anyWin }
        // -------------------------
        if (Array.isArray(data.draws) && Array.isArray(data.results)) {
          const scope = data.meta?.scope || data.scope || effectiveScope || {};
          const label = scopeToLabel(scope);
  
          // merge + ALWAYS compute detail client-side
          const merged = mergeDrawsResults(data.draws, data.results);
  
          const ticketNow = buildTicket();
          const mergedComputed = merged.map(item => {
            const computed = computeUnitsClient(ticketNow, {
              numbers: (item.numbers || []).map(Number),
              extra: Number(item.extra || 0),
            });
  
            const summary = Array.isArray(computed.summary) ? computed.summary : [];
            const isWin = summary.length > 0;
  
            return {
              ...item,
              summary,
              isWin,
              bestHit: computed.bestHit || item.bestHit,
            };
          });
  
          // If user specified single drawNo/drawDate, render as single view
          if (scope.drawNo) {
            const targetNo = normalizeDrawNo(scope.drawNo);
            const item = mergedComputed.find(x => x.drawNoN === targetNo) || mergedComputed.find(x => normalizeDrawNo(x.drawNo) === targetNo);
  
            if (!item) {
              mainResultEl.innerHTML = `<div class="error">找不到指定期數（${targetNo}）。</div>`;
              recentBlockEl.innerHTML = "";
              return;
            }
  
            mainResultEl.innerHTML = renderSingleComputed(ticketNow, item, label);
            recentBlockEl.innerHTML = "";
            return;
          }
  
          if (scope.drawDate) {
            const targetDate = String(scope.drawDate).trim();
            const item = mergedComputed.find(x => String(x.drawDate).trim() === targetDate);
  
            if (!item) {
              mainResultEl.innerHTML = `<div class="error">找不到指定日期（${targetDate}）。</div>`;
              recentBlockEl.innerHTML = "";
              return;
            }
  
            mainResultEl.innerHTML = renderSingleComputed(ticketNow, item, label);
            recentBlockEl.innerHTML = "";
            return;
          }
  
          // Range/multi view: render wins list with computed summaries
          const anyWin2 = mergedComputed.some(x => x.isWin);
          mainResultEl.innerHTML =
            `<div class="muted">核對範圍：${label}｜共 ${mergedComputed.length} 期｜${anyWin2 ? "有中獎" : "未有中獎"}</div>`;
          recentBlockEl.innerHTML = renderRecent(mergedComputed, label);
          return;
        }
  
        // -------------------------
        // ✅ OLD API SHAPE fallback:
        // data.main / data.recentWins / data.rangeInfo / data.multiInfo
        // -------------------------
        const q = data.query || data.scope || {};
        const isMulti = !!data.multiInfo || !!q.multi;
  
        if (isMulti) {
          mainResultEl.innerHTML =
            `<div><strong>多期核對：</strong>由 ${data.multiInfo?.startDrawNo || q.startDrawNo} 起，共 ${data.multiInfo?.checked || "—"} 期（設定：${data.multiInfo?.count || q.multiCount || "—"} 期）</div>`;
          recentBlockEl.innerHTML = renderRecent(data.multiWins || [], `多期核對（${data.multiInfo?.startDrawNo || q.startDrawNo} 起）`);
        } else if (!q.drawNo && !q.drawDate) {
          mainResultEl.innerHTML = data.rangeInfo?.label
            ? `<div class="muted">核對範圍：${data.rangeInfo.label}</div>`
            : "";
          const label2 = data.rangeInfo?.label || "近60日";
          recentBlockEl.innerHTML = renderRecent(data.recentWins || [], label2);
        } else {
          // best effort
          mainResultEl.innerHTML = `<div class="muted">已核對指定期數/日期，但舊版回傳格式未覆蓋。建議用新版 draws/results。</div>`;
          recentBlockEl.innerHTML = "";
        }
  
      }catch(e){
        statusEl.textContent="";
        inputErrEl.textContent = "核對失敗：" + e.message;
        mainResultEl.innerHTML = `<div class="error">核對失敗：${e.message}</div>`;
      }
    }
  
    document.getElementById("check").addEventListener("click", runCheck);
  
    // init
    updateHint();
    updateChancesStake();
    updateHalfVisibility();
    updateRangeVisibility();
  </script>



</body>
</html>
